+++
title = "Property based testing"
description = "Preaching of a property-based testing church adept"
date = 2021-03-06T17:26:26+03:00
draft = true
+++


# Property-based тестирование

Если немного прищуриться, большинство тестов выглядит абсолютно одинаково:

```python3
def test_f():
    input = "..."
    actual = f(input)
    assert actual == expected
```

Для многих подобная конструкция вообще является синонимом слова "тест".
Я постараюсь познакомить вас с другим способом написания тестов.

Но для начала давайте поймем, что же объединяет большинство существующих
тестов? Они все основаны на примерах, образцах правильного поведения:

```python3
def test_my_sort():
    assert my_sort([]) == []
    assert my_sort([1, 2]) == [1, 2]
    assert my_sort([3, 2, 1]) == [1, 2, 3]
```

Это example-based тест. Его легко написать, но какова его реальная ценность?
Если кто-то изменит функцию `my_sort` так, что ее поведение на этих примерах
изменится -- тест упадет, и мы об этом узнаем. Уже неплохо! Дает ли этот тест
нам уверенность в том, что `my_sort` действительно корректно работает? Нет.
Возможно, стоит увеличить количество примеров? Но какого именно количества достаточно?
Возможно, стоит добавлять примеры, пока не добъемся "100% покрытия"? Но как
связано покрытие участков исходного кода с покрытием путей в пространстве состояний
выполнения кода?

Я предлагаю попробовать подойти к задаче с другой стороны. Если нас интересует
корректность -- давайте попробуем определить, что же это такое. Поставьте себя
на место пользователя библиотеки: что значит, что она работает корректно? Как
пользователь, вы не мыслите примерами, вы мыслите свойствами. Например: "данные,
записанные в базу, можно считать обратно", "обход этого контейнера должен
происходить в порядке возрастания ключей", "эта функция возвращает значение между
0 и 1". Вы создаете код, полагаясь на свойства используемого кода. Поэтому предлагаю
упрощенно определить корректность как выполнение ожидаемых (пользователем) свойств.

Давайте вернемся к нашей сортировке. Какие свойства может ожидать пользователь?
Вот первые, что приходят на ум:

1. `my_sort` не модифицирует входные данные;
2. результат состоит из тех же элементов, что и входные данные;
3. результат отсортирован.

Как проверить, выполняются ли они? Для полной уверенности хотелось бы их доказать!
Но это сложно, и требует совсем другого инструментария, чем наш любимый язык и фреймворк
для тестирования. Что же делать? Все просто: зачастую нам достаточно не абсолютной
уверенности, и наша уверенность обычно пропорциональна количеству случаев,
при которых мы наблюдали выполнение свойства. Давайте начнем с проверки того,
что наше свойство выполняется для 100 наборов входных данных... но где же их взять?
Сгенерируем случайные! С помощью [Hypothesis](https://hypothesis.readthedocs.io/en/latest/index.html):

```python3
from hypothesis import given
from hypothesis.strategies import lists, integers

@given(a=lists(integers()))
def test_my_sort_does_not_change_input(a):
    c = a.copy()
    my_sort(a)
    assert a == c

@given(a=lists(integers()))
def test_my_sort_is_a_permutation(a):
    s = my_sort(a)
    assert set(s) == set(a)

@given(a=lists(integers()))
def test_my_sort_result_is_sorted(a):
    s = my_sort(a)
    assert all(s[i] <= s[i+1] for i in range(len(s)-1))
```



























































---

- optimize bug finding given limited time budget for tests
- example vs property
- unit vs integration
- test at the API/abstraction boundary layer (no matter big or small)
- fscheck:
  - “Different paths, same destination” – a diagram that commutes
  - “There and back again” – an invertible function
  - “Some things never change” – an invariant under transformation
  - “The more things change, the more they stay the same” – idempotence
  - “Solve a smaller problem first” – structural induction
  - “Hard to prove, easy to verify”
  - “A test oracle”
- jessica kerr:
  - expect and create failure
  - ask hard questions
  - create visibility you need
  - define success
- math:
  - associative
  - commutative
  - distributive
  - idempotent
  - identity
  - zero
- proper
  - sit back and think
  - start broad and build up
  - assemble multiple properties
- Небольшой список примеров из самых разных областей, удобных для проверки свойств:
  - поле класса должно иметь ранее присвоенное значение (геттеры-сеттеры)
  - в хранилище должна быть возможность прочитать ранее записанный элемент
  - добавление ранее несуществующего элемента в хранилище не затрагивает ранее добавленные элементы
  - во многих словарях не могут храниться несколько разных элементов с одинаковым ключом
  - высота сбалансированного дерева должна быть не больше , где  — число записанных элементов
  - результатом сортировки является список упорядоченных элементов
  - результат кодирования в base64 должен содержать только символы из алфавита base64
  - алгоритм построения маршрута должен возвращать последовательность допустимых перемещений, которая приведет из точки A в точку B
  - для всех точек построенных изолиний должно выполняться
  - алгоритм проверки электронной подписи должен возвращать True, если подпись настоящая и False в противном случае
  - в результате ортонормирования все вектора в базисе должны иметь единичную длину и нулевые взаимные скалярные произведения
  - операции переноса и вращения вектора не должны менять его длину
